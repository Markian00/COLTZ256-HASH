# COLTZ256-HASH
This work is an original product of mine, however, I drew inspiration from independent researcher Fabian Bocart after reading his paper on "Inflation Propensity of Collatz Orbits" in the Journal of Risk and Financial Management.

Here I have created a cryptographic hash function with a 256-bit output leveraging the properties of the unsolved Collatz Conjecture. SHA-256 is perhaps the best-known hashing algorithm today. In 2017 a technical flaw in SHA-256 was documented that allowed for optimizations (for example "ASIC-BOOST") which put certain individuals ahead of the curve in cryptocurrency mining (Risking a 50% attack on the blockchain). By exploiting collisions of similar headers in the blockchain when hashing they could mine several times faster than competing "miners". SHA-256's flaws make it exploitable, meaning it may not be a reliable algorithm for cryptographic hashing. Our over-reliance on SHA-256 is clear to SWEs around the globe, so we need alternatives (and replacements) to ensure communal welfare if the worst were to happen.

Proof of Information-Theoretic Security:
The Collatz Conjecture has never been solved and has existed since at least 1937. To find the integer that corresponds to the hash, we would require a closed form for the Collatz conjecture's recursive formulation. This is at least as hard as solving the conjecture since a closed form would allow for a proof of the conjecture. This means that the algorithm can't be inverted to yield the original value pre-hashing, nor can it be inverted to yield a set of potential values. Colliding hashes further mask any potential attempts to decode the input (as with most hash functions).

In future updates, this will be made more secure by preventing exploits made possible by measuring CPU data to reverse engineer the input (as can be done with SHA256). The implementation of a multithreaded system that computes each of the 32 8-bit sub-hashes in separate threads will solve this.

Hash Collision Analysis:
A proof for the collisions of values input into the Collatz Conjecture recursive formulation would be at least as difficult as proving the conjecture itself since you would need a relatively solid understanding of how input values correspond to output values. The best we can do is state the following: for the first 7 billion integers of input, the average number of iterations is between 140 and 200 (but ranges from 0 to 456). Since each iteration can count as 1 or 2 added to the encrypted value, which is an 8-bit unsigned integer, the values should properly range between 0 and 256 for each of the 32 subsections of the final hash. The distribution can't be further documented, but the SHA256 distribution is not well documented either. In fact, there is no proof of its distribution, its power comes from the trust placed in it. 

Utility in WEB3 development and Cryptography:
The properties of the Collatz Conjecture allow small differences in input to produce drastically different outputs. We use this to prevent exploitation using techniques like "ASIC-BOOST" making COLTZ256-HASH a better algorithm for cryptocurrency block-chain implementations. The value of Bitcoin today could be several times higher if it weren't for techniques like "ASIC-BOOST" lowering the cost of mining a single coin. Implementing COLTZ256-HASH is useful to prevent both 50% attacks and cryptocurrency inflation in a way SHA-256 can't promise.
